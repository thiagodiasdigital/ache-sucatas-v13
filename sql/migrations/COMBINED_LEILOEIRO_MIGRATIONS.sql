-- ============================================================================
-- MIGRACOES COMBINADAS: Pipeline leiloesjudiciais
-- Data: 2026-01-30
--
-- INSTRUCOES:
-- 1. Abra o Supabase Dashboard -> SQL Editor
-- 2. Cole este arquivo inteiro
-- 3. Execute (Ctrl+Enter ou botao Run)
-- 4. Verifique os logs para confirmar sucesso de cada migracao
-- ============================================================================

-- ============================================================================
-- MIGRACAO 010: Criar tabela staging leiloeiro_lotes_raw
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.leiloeiro_lotes_raw (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content_hash TEXT NOT NULL,
    lote_id TEXT NOT NULL,
    leilao_id TEXT,
    api_response JSONB NOT NULL,
    tipo INTEGER,
    categoria TEXT,
    processing_status TEXT DEFAULT 'pending'
        CHECK (processing_status IN ('pending', 'processed', 'rejected')),
    processed_at TIMESTAMPTZ,
    rejection_reason TEXT,
    run_id TEXT,
    api_page INTEGER,
    api_endpoint TEXT DEFAULT '/core/api/get-lotes',
    http_status INTEGER,
    fetched_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT uq_leiloeiro_raw_content_hash UNIQUE (content_hash)
);

CREATE INDEX IF NOT EXISTS idx_leiloeiro_raw_content_hash ON public.leiloeiro_lotes_raw(content_hash);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_raw_status ON public.leiloeiro_lotes_raw(processing_status);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_raw_lote_id ON public.leiloeiro_lotes_raw(lote_id);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_raw_tipo ON public.leiloeiro_lotes_raw(tipo);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_raw_run_id ON public.leiloeiro_lotes_raw(run_id);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_raw_fetched_at ON public.leiloeiro_lotes_raw(fetched_at DESC);

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_updated_at_column') THEN
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $func$
        BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
        END;
        $func$ LANGUAGE plpgsql;
    END IF;
END $$;

DROP TRIGGER IF EXISTS update_leiloeiro_raw_updated_at ON public.leiloeiro_lotes_raw;
CREATE TRIGGER update_leiloeiro_raw_updated_at
    BEFORE UPDATE ON public.leiloeiro_lotes_raw
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

ALTER TABLE public.leiloeiro_lotes_raw ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service role full access leiloeiro_raw" ON public.leiloeiro_lotes_raw;
CREATE POLICY "Service role full access leiloeiro_raw"
    ON public.leiloeiro_lotes_raw FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Authenticated read leiloeiro_raw" ON public.leiloeiro_lotes_raw;
CREATE POLICY "Authenticated read leiloeiro_raw"
    ON public.leiloeiro_lotes_raw FOR SELECT TO authenticated USING (true);

-- MIGRACAO 010 CONCLUIDA: leiloeiro_lotes_raw criada

-- ============================================================================
-- MIGRACAO 011: Criar tabela normalizada leiloeiro_lotes
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.leiloeiro_lotes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_interno TEXT NOT NULL UNIQUE,
    lote_id_original TEXT NOT NULL,
    leilao_id_original TEXT,
    titulo TEXT NOT NULL,
    descricao TEXT,
    objeto_resumido TEXT,
    cidade TEXT,
    uf CHAR(2),
    data_leilao TIMESTAMPTZ,
    data_publicacao DATE,
    valor_avaliacao NUMERIC(15, 2),
    valor_lance_inicial NUMERIC(15, 2),
    valor_incremento NUMERIC(15, 2),
    link_leiloeiro TEXT,
    link_edital TEXT,
    tags TEXT[] NOT NULL DEFAULT '{}',
    categoria TEXT,
    tipo_leilao TEXT,
    orgao TEXT DEFAULT 'Leilao Judicial',
    nome_leiloeiro TEXT,
    n_edital TEXT,
    source_type TEXT NOT NULL DEFAULT 'leiloeiro' CHECK (source_type = 'leiloeiro'),
    source_name TEXT NOT NULL DEFAULT 'Leiloes Judiciais',
    metadata JSONB DEFAULT '{}',
    imagens TEXT[] DEFAULT '{}',
    confidence_score INTEGER DEFAULT 50 CHECK (confidence_score >= 0 AND confidence_score <= 100),
    publication_status TEXT DEFAULT 'published' CHECK (publication_status IN ('draft', 'published', 'archived')),
    raw_id BIGINT REFERENCES public.leiloeiro_lotes_raw(id),
    versao_pipeline TEXT DEFAULT 'v1.0',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_id_interno ON public.leiloeiro_lotes(id_interno);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_data_leilao ON public.leiloeiro_lotes(data_leilao DESC);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_uf ON public.leiloeiro_lotes(uf);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_cidade ON public.leiloeiro_lotes(cidade);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_status ON public.leiloeiro_lotes(publication_status);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_tags ON public.leiloeiro_lotes USING GIN(tags);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_lote_id_original ON public.leiloeiro_lotes(lote_id_original);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_lotes_source_lote ON public.leiloeiro_lotes(source_name, lote_id_original);

DROP TRIGGER IF EXISTS update_leiloeiro_lotes_updated_at ON public.leiloeiro_lotes;
CREATE TRIGGER update_leiloeiro_lotes_updated_at
    BEFORE UPDATE ON public.leiloeiro_lotes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

ALTER TABLE public.leiloeiro_lotes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service role full access leiloeiro_lotes" ON public.leiloeiro_lotes;
CREATE POLICY "Service role full access leiloeiro_lotes"
    ON public.leiloeiro_lotes FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Anon read published leiloeiro_lotes" ON public.leiloeiro_lotes;
CREATE POLICY "Anon read published leiloeiro_lotes"
    ON public.leiloeiro_lotes FOR SELECT TO anon USING (publication_status = 'published');

DROP POLICY IF EXISTS "Authenticated read published leiloeiro_lotes" ON public.leiloeiro_lotes;
CREATE POLICY "Authenticated read published leiloeiro_lotes"
    ON public.leiloeiro_lotes FOR SELECT TO authenticated USING (publication_status = 'published');

CREATE OR REPLACE FUNCTION public.upsert_leiloeiro_lote(
    p_id_interno TEXT,
    p_lote_id_original TEXT,
    p_leilao_id_original TEXT,
    p_titulo TEXT,
    p_descricao TEXT,
    p_objeto_resumido TEXT,
    p_cidade TEXT,
    p_uf CHAR(2),
    p_data_leilao TIMESTAMPTZ,
    p_valor_avaliacao NUMERIC,
    p_link_leiloeiro TEXT,
    p_link_edital TEXT,
    p_tags TEXT[],
    p_categoria TEXT,
    p_tipo_leilao TEXT,
    p_nome_leiloeiro TEXT,
    p_imagens TEXT[],
    p_metadata JSONB,
    p_confidence_score INTEGER,
    p_raw_id BIGINT
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_id BIGINT;
BEGIN
    INSERT INTO public.leiloeiro_lotes (
        id_interno, lote_id_original, leilao_id_original,
        titulo, descricao, objeto_resumido,
        cidade, uf, data_leilao,
        valor_avaliacao, link_leiloeiro, link_edital,
        tags, categoria, tipo_leilao,
        nome_leiloeiro, imagens, metadata,
        confidence_score, raw_id, data_publicacao
    )
    VALUES (
        p_id_interno, p_lote_id_original, p_leilao_id_original,
        p_titulo, p_descricao, p_objeto_resumido,
        p_cidade, p_uf, p_data_leilao,
        p_valor_avaliacao, p_link_leiloeiro, p_link_edital,
        COALESCE(p_tags, '{}'), p_categoria, p_tipo_leilao,
        p_nome_leiloeiro, COALESCE(p_imagens, '{}'), COALESCE(p_metadata, '{}'),
        COALESCE(p_confidence_score, 50), p_raw_id, CURRENT_DATE
    )
    ON CONFLICT (id_interno) DO UPDATE SET
        titulo = EXCLUDED.titulo,
        descricao = EXCLUDED.descricao,
        objeto_resumido = EXCLUDED.objeto_resumido,
        cidade = EXCLUDED.cidade,
        uf = EXCLUDED.uf,
        data_leilao = EXCLUDED.data_leilao,
        valor_avaliacao = EXCLUDED.valor_avaliacao,
        link_leiloeiro = EXCLUDED.link_leiloeiro,
        link_edital = EXCLUDED.link_edital,
        tags = EXCLUDED.tags,
        metadata = EXCLUDED.metadata,
        confidence_score = EXCLUDED.confidence_score,
        updated_at = NOW()
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.upsert_leiloeiro_lote TO service_role;

-- MIGRACAO 011 CONCLUIDA: leiloeiro_lotes criada

-- ============================================================================
-- MIGRACAO 012: Criar tabela de quarentena
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.leiloeiro_quarantine (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    raw_id BIGINT REFERENCES public.leiloeiro_lotes_raw(id),
    id_interno TEXT,
    lote_id_original TEXT,
    rejection_code TEXT NOT NULL,
    rejection_reason TEXT NOT NULL,
    validation_errors TEXT[] DEFAULT '{}',
    payload_original JSONB NOT NULL,
    normalized_data JSONB,
    run_id TEXT,
    pipeline_version TEXT DEFAULT 'v1.0',
    failed_at_stage TEXT DEFAULT 'validation'
        CHECK (failed_at_stage IN ('fetch', 'normalize', 'validation', 'persist')),
    processed_at TIMESTAMPTZ DEFAULT NOW(),
    status TEXT DEFAULT 'pending'
        CHECK (status IN ('pending', 'resolved', 'discarded')),
    resolved_at TIMESTAMPTZ,
    resolved_by TEXT,
    resolution_notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_leiloeiro_quarantine_status ON public.leiloeiro_quarantine(status);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_quarantine_code ON public.leiloeiro_quarantine(rejection_code);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_quarantine_run_id ON public.leiloeiro_quarantine(run_id);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_quarantine_lote_id ON public.leiloeiro_quarantine(lote_id_original);
CREATE INDEX IF NOT EXISTS idx_leiloeiro_quarantine_created_at ON public.leiloeiro_quarantine(created_at DESC);

DROP TRIGGER IF EXISTS update_leiloeiro_quarantine_updated_at ON public.leiloeiro_quarantine;
CREATE TRIGGER update_leiloeiro_quarantine_updated_at
    BEFORE UPDATE ON public.leiloeiro_quarantine
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

ALTER TABLE public.leiloeiro_quarantine ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service role full access leiloeiro_quarantine" ON public.leiloeiro_quarantine;
CREATE POLICY "Service role full access leiloeiro_quarantine"
    ON public.leiloeiro_quarantine FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Authenticated read leiloeiro_quarantine" ON public.leiloeiro_quarantine;
CREATE POLICY "Authenticated read leiloeiro_quarantine"
    ON public.leiloeiro_quarantine FOR SELECT TO authenticated USING (true);

CREATE TABLE IF NOT EXISTS public.leiloeiro_rejection_codes (
    code TEXT PRIMARY KEY,
    description TEXT NOT NULL,
    severity TEXT DEFAULT 'error' CHECK (severity IN ('warning', 'error', 'fatal')),
    is_recoverable BOOLEAN DEFAULT false
);

INSERT INTO public.leiloeiro_rejection_codes (code, description, severity, is_recoverable)
VALUES
    ('TIPO_3', 'Leilao tipo 3 (hibrido) nao suportado pelo escopo', 'fatal', false),
    ('MISSING_DATA_LEILAO', 'Campo obrigatorio data_leilao ausente', 'error', true),
    ('MISSING_TAGS', 'Campo obrigatorio tags ausente ou vazio', 'error', true),
    ('INVALID_UF', 'UF invalida ou nao reconhecida', 'error', true),
    ('INVALID_TITULO', 'Titulo ausente ou invalido', 'error', true),
    ('MISSING_ID_INTERNO', 'Falha ao gerar id_interno', 'fatal', false),
    ('DUPLICATE_CONTENT', 'Conteudo duplicado (mesmo content_hash)', 'warning', false),
    ('API_ERROR', 'Erro ao buscar dados da API', 'error', true),
    ('PARSE_ERROR', 'Erro ao parsear resposta da API', 'error', true),
    ('CATEGORY_EXCLUDED', 'Categoria excluida do escopo (ex: imoveis)', 'fatal', false),
    ('EXPIRED_AUCTION', 'Leilao ja encerrado', 'warning', false)
ON CONFLICT (code) DO NOTHING;

CREATE OR REPLACE FUNCTION public.quarantine_leiloeiro_lote(
    p_raw_id BIGINT,
    p_id_interno TEXT,
    p_lote_id_original TEXT,
    p_rejection_code TEXT,
    p_rejection_reason TEXT,
    p_validation_errors TEXT[],
    p_payload_original JSONB,
    p_normalized_data JSONB,
    p_run_id TEXT,
    p_failed_at_stage TEXT DEFAULT 'validation'
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_id BIGINT;
BEGIN
    INSERT INTO public.leiloeiro_quarantine (
        raw_id, id_interno, lote_id_original,
        rejection_code, rejection_reason, validation_errors,
        payload_original, normalized_data,
        run_id, failed_at_stage
    )
    VALUES (
        p_raw_id, p_id_interno, p_lote_id_original,
        p_rejection_code, p_rejection_reason, COALESCE(p_validation_errors, '{}'),
        p_payload_original, p_normalized_data,
        p_run_id, COALESCE(p_failed_at_stage, 'validation')
    )
    RETURNING id INTO v_id;

    IF p_raw_id IS NOT NULL THEN
        UPDATE public.leiloeiro_lotes_raw
        SET processing_status = 'rejected',
            rejection_reason = p_rejection_code,
            processed_at = NOW()
        WHERE id = p_raw_id;
    END IF;

    RETURN v_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.quarantine_leiloeiro_lote TO service_role;

CREATE OR REPLACE VIEW public.v_leiloeiro_quarantine_summary AS
SELECT
    rejection_code,
    COUNT(*) AS total,
    COUNT(*) FILTER (WHERE status = 'pending') AS pending,
    COUNT(*) FILTER (WHERE status = 'resolved') AS resolved,
    COUNT(*) FILTER (WHERE status = 'discarded') AS discarded,
    MIN(created_at) AS first_occurrence,
    MAX(created_at) AS last_occurrence
FROM public.leiloeiro_quarantine
GROUP BY rejection_code
ORDER BY total DESC;

-- MIGRACAO 012 CONCLUIDA: leiloeiro_quarantine criada

-- ============================================================================
-- MIGRACAO 013: Criar view unificada
-- ============================================================================

CREATE OR REPLACE VIEW pub.v_dashboard_lotes_unificado AS
-- PNCP
SELECT
    l.id,
    l.id_interno,
    l.pncp_id,
    l.orgao,
    l.uf,
    l.cidade,
    l.n_edital,
    l.data_publicacao,
    l.data_leilao,
    l.titulo,
    l.descricao,
    l.objeto_resumido,
    l.tags,
    CASE
        WHEN l.storage_path IS NOT NULL AND l.storage_path <> ''
        THEN l.storage_path
        ELSE l.link_pncp
    END AS link_edital,
    l.link_leiloeiro,
    l.modalidade_leilao,
    l.valor_estimado,
    l.quantidade_itens,
    l.nome_leiloeiro,
    l.storage_path,
    l.score,
    l.created_at,
    'pncp'::TEXT AS source_type,
    'Portal Nacional de Contratacoes Publicas'::TEXT AS source_name,
    '{}'::JSONB AS metadata,
    m.codigo_ibge,
    m.latitude,
    m.longitude,
    m.nome_municipio AS municipio_oficial,
    CASE
        WHEN l.data_leilao >= CURRENT_DATE THEN 'futuro'
        ELSE 'passado'
    END AS status_temporal
FROM raw.leiloes l
LEFT JOIN pub.ref_municipios m
    ON UPPER(TRIM(l.cidade)) = UPPER(TRIM(m.nome_municipio))
    AND l.uf = m.uf
WHERE
    l.publication_status = 'published'
    AND l.data_leilao IS NOT NULL
    AND l.link_pncp IS NOT NULL

UNION ALL

-- LEILOEIRO
SELECT
    ll.id,
    ll.id_interno,
    NULL::TEXT AS pncp_id,
    ll.orgao,
    ll.uf,
    ll.cidade,
    ll.n_edital,
    ll.data_publicacao,
    ll.data_leilao,
    ll.titulo,
    ll.descricao,
    ll.objeto_resumido,
    ll.tags,
    ll.link_edital,
    ll.link_leiloeiro,
    ll.tipo_leilao AS modalidade_leilao,
    ll.valor_avaliacao AS valor_estimado,
    1 AS quantidade_itens,
    ll.nome_leiloeiro,
    NULL::TEXT AS storage_path,
    ll.confidence_score AS score,
    ll.created_at,
    ll.source_type,
    ll.source_name,
    ll.metadata,
    m.codigo_ibge,
    m.latitude,
    m.longitude,
    m.nome_municipio AS municipio_oficial,
    CASE
        WHEN ll.data_leilao >= CURRENT_DATE THEN 'futuro'
        ELSE 'passado'
    END AS status_temporal
FROM public.leiloeiro_lotes ll
LEFT JOIN pub.ref_municipios m
    ON UPPER(TRIM(ll.cidade)) = UPPER(TRIM(m.nome_municipio))
    AND ll.uf = m.uf
WHERE
    ll.publication_status = 'published'
    AND ll.data_leilao IS NOT NULL;

GRANT SELECT ON pub.v_dashboard_lotes_unificado TO anon;
GRANT SELECT ON pub.v_dashboard_lotes_unificado TO authenticated;

CREATE OR REPLACE FUNCTION public.get_dashboard_stats_unified()
RETURNS TABLE (
    total_lotes BIGINT,
    total_pncp BIGINT,
    total_leiloeiro BIGINT,
    total_ufs BIGINT,
    total_cidades BIGINT,
    valor_total NUMERIC,
    lotes_futuros BIGINT,
    lotes_passados BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::BIGINT AS total_lotes,
        COUNT(*) FILTER (WHERE source_type = 'pncp')::BIGINT AS total_pncp,
        COUNT(*) FILTER (WHERE source_type = 'leiloeiro')::BIGINT AS total_leiloeiro,
        COUNT(DISTINCT uf)::BIGINT AS total_ufs,
        COUNT(DISTINCT cidade)::BIGINT AS total_cidades,
        COALESCE(SUM(valor_estimado), 0)::NUMERIC AS valor_total,
        COUNT(*) FILTER (WHERE status_temporal = 'futuro')::BIGINT AS lotes_futuros,
        COUNT(*) FILTER (WHERE status_temporal = 'passado')::BIGINT AS lotes_passados
    FROM pub.v_dashboard_lotes_unificado;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_dashboard_stats_unified TO anon;
GRANT EXECUTE ON FUNCTION public.get_dashboard_stats_unified TO authenticated;

-- MIGRACAO 013 CONCLUIDA: v_dashboard_lotes_unificado criada

-- ============================================================================
-- MIGRACAO 014: Criar RPCs unificadas
-- ============================================================================

CREATE OR REPLACE FUNCTION public.fetch_auctions_unified(
    p_uf TEXT DEFAULT NULL,
    p_cidade TEXT DEFAULT NULL,
    p_valor_min NUMERIC DEFAULT NULL,
    p_valor_max NUMERIC DEFAULT NULL,
    p_data_leilao_de DATE DEFAULT NULL,
    p_data_leilao_ate DATE DEFAULT NULL,
    p_page INTEGER DEFAULT 1,
    p_page_size INTEGER DEFAULT 20,
    p_ordenacao TEXT DEFAULT 'proximos',
    p_temporalidade TEXT DEFAULT 'futuros',
    p_source TEXT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_total INTEGER;
    v_total_pages INTEGER;
    v_offset INTEGER;
    v_data JSON;
BEGIN
    v_offset := (COALESCE(p_page, 1) - 1) * COALESCE(p_page_size, 20);

    SELECT COUNT(*) INTO v_total
    FROM pub.v_dashboard_lotes_unificado v
    WHERE
        (p_uf IS NULL OR v.uf = p_uf)
        AND (p_cidade IS NULL OR UPPER(TRIM(v.cidade)) LIKE UPPER(TRIM('%' || p_cidade || '%')))
        AND (p_valor_min IS NULL OR v.valor_estimado >= p_valor_min)
        AND (p_valor_max IS NULL OR v.valor_estimado <= p_valor_max)
        AND (p_data_leilao_de IS NULL OR v.data_leilao::DATE >= p_data_leilao_de)
        AND (p_data_leilao_ate IS NULL OR v.data_leilao::DATE <= p_data_leilao_ate)
        AND (
            p_temporalidade = 'todos'
            OR (p_temporalidade = 'futuros' AND v.status_temporal = 'futuro')
            OR (p_temporalidade = 'passados' AND v.status_temporal = 'passado')
        )
        AND (p_source IS NULL OR v.source_type = p_source);

    v_total_pages := CEIL(GREATEST(v_total, 1)::DECIMAL / COALESCE(p_page_size, 20));

    SELECT json_agg(row_to_json(t)) INTO v_data
    FROM (
        SELECT
            v.id, v.id_interno, v.pncp_id, v.orgao, v.uf, v.cidade, v.n_edital,
            v.data_publicacao, v.data_leilao, v.titulo, v.descricao, v.objeto_resumido,
            v.tags, v.link_edital, v.link_leiloeiro, v.modalidade_leilao, v.valor_estimado,
            v.quantidade_itens, v.nome_leiloeiro, v.storage_path, v.score, v.created_at,
            v.source_type, v.source_name, v.metadata, v.codigo_ibge, v.latitude, v.longitude,
            v.municipio_oficial, v.status_temporal
        FROM pub.v_dashboard_lotes_unificado v
        WHERE
            (p_uf IS NULL OR v.uf = p_uf)
            AND (p_cidade IS NULL OR UPPER(TRIM(v.cidade)) LIKE UPPER(TRIM('%' || p_cidade || '%')))
            AND (p_valor_min IS NULL OR v.valor_estimado >= p_valor_min)
            AND (p_valor_max IS NULL OR v.valor_estimado <= p_valor_max)
            AND (p_data_leilao_de IS NULL OR v.data_leilao::DATE >= p_data_leilao_de)
            AND (p_data_leilao_ate IS NULL OR v.data_leilao::DATE <= p_data_leilao_ate)
            AND (
                p_temporalidade = 'todos'
                OR (p_temporalidade = 'futuros' AND v.status_temporal = 'futuro')
                OR (p_temporalidade = 'passados' AND v.status_temporal = 'passado')
            )
            AND (p_source IS NULL OR v.source_type = p_source)
        ORDER BY
            CASE WHEN p_ordenacao = 'proximos' THEN v.data_leilao END ASC NULLS LAST,
            CASE WHEN p_ordenacao = 'distantes' THEN v.data_leilao END DESC NULLS LAST,
            CASE WHEN p_ordenacao = 'valor_desc' THEN v.valor_estimado END DESC NULLS LAST,
            CASE WHEN p_ordenacao = 'valor_asc' THEN v.valor_estimado END ASC NULLS LAST
        LIMIT p_page_size
        OFFSET v_offset
    ) t;

    RETURN json_build_object(
        'data', COALESCE(v_data, '[]'::JSON),
        'total', v_total,
        'page', COALESCE(p_page, 1),
        'pageSize', COALESCE(p_page_size, 20),
        'totalPages', v_total_pages,
        'source_filter', p_source
    );
END;
$$;

GRANT EXECUTE ON FUNCTION public.fetch_auctions_unified TO authenticated;
GRANT EXECUTE ON FUNCTION public.fetch_auctions_unified TO anon;

CREATE OR REPLACE FUNCTION public.get_available_ufs_unified(
    p_source TEXT DEFAULT NULL
)
RETURNS TABLE (uf CHAR(2), count BIGINT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT v.uf::CHAR(2), COUNT(*)::BIGINT
    FROM pub.v_dashboard_lotes_unificado v
    WHERE v.uf IS NOT NULL AND v.status_temporal = 'futuro'
        AND (p_source IS NULL OR v.source_type = p_source)
    GROUP BY v.uf
    ORDER BY COUNT(*) DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_available_ufs_unified TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_available_ufs_unified TO anon;

CREATE OR REPLACE FUNCTION public.get_cities_by_uf_unified(
    p_uf CHAR(2),
    p_source TEXT DEFAULT NULL
)
RETURNS TABLE (cidade TEXT, count BIGINT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT v.cidade::TEXT, COUNT(*)::BIGINT
    FROM pub.v_dashboard_lotes_unificado v
    WHERE v.uf = p_uf AND v.cidade IS NOT NULL AND v.status_temporal = 'futuro'
        AND (p_source IS NULL OR v.source_type = p_source)
    GROUP BY v.cidade
    ORDER BY COUNT(*) DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_cities_by_uf_unified TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_cities_by_uf_unified TO anon;

-- MIGRACAO 014 CONCLUIDA: RPCs unificadas criadas

-- ============================================================================
-- VERIFICACAO FINAL
-- ============================================================================

DO $$
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'TODAS AS MIGRACOES APLICADAS!';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Tabelas: leiloeiro_lotes_raw, leiloeiro_lotes, leiloeiro_quarantine';
    RAISE NOTICE 'View: pub.v_dashboard_lotes_unificado';
    RAISE NOTICE 'RPCs: fetch_auctions_unified, get_available_ufs_unified, get_cities_by_uf_unified';
    RAISE NOTICE '';
    RAISE NOTICE 'Proximo passo: testar pipeline Python';
    RAISE NOTICE 'python -m connectors.leiloesjudiciais.run_api_pipeline --dry-run';
    RAISE NOTICE '========================================';
END $$;
